/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package spdxfakes

import (
	"sync"

	"k8s.io/release/pkg/spdx"
)

type FakeSpdxImplementation struct {
	ExtractTarballTmpStub        func(string) (string, error)
	extractTarballTmpMutex       sync.RWMutex
	extractTarballTmpArgsForCall []struct {
		arg1 string
	}
	extractTarballTmpReturns struct {
		result1 string
		result2 error
	}
	extractTarballTmpReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	PackageFromLayerTarBallStub        func(string, *spdx.TarballOptions) (*spdx.Package, error)
	packageFromLayerTarBallMutex       sync.RWMutex
	packageFromLayerTarBallArgsForCall []struct {
		arg1 string
		arg2 *spdx.TarballOptions
	}
	packageFromLayerTarBallReturns struct {
		result1 *spdx.Package
		result2 error
	}
	packageFromLayerTarBallReturnsOnCall map[int]struct {
		result1 *spdx.Package
		result2 error
	}
	PullImagesToArchiveStub        func(string, string) error
	pullImagesToArchiveMutex       sync.RWMutex
	pullImagesToArchiveArgsForCall []struct {
		arg1 string
		arg2 string
	}
	pullImagesToArchiveReturns struct {
		result1 error
	}
	pullImagesToArchiveReturnsOnCall map[int]struct {
		result1 error
	}
	ReadArchiveManifestStub        func(string) (*spdx.ArchiveManifest, error)
	readArchiveManifestMutex       sync.RWMutex
	readArchiveManifestArgsForCall []struct {
		arg1 string
	}
	readArchiveManifestReturns struct {
		result1 *spdx.ArchiveManifest
		result2 error
	}
	readArchiveManifestReturnsOnCall map[int]struct {
		result1 *spdx.ArchiveManifest
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSpdxImplementation) ExtractTarballTmp(arg1 string) (string, error) {
	fake.extractTarballTmpMutex.Lock()
	ret, specificReturn := fake.extractTarballTmpReturnsOnCall[len(fake.extractTarballTmpArgsForCall)]
	fake.extractTarballTmpArgsForCall = append(fake.extractTarballTmpArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ExtractTarballTmpStub
	fakeReturns := fake.extractTarballTmpReturns
	fake.recordInvocation("ExtractTarballTmp", []interface{}{arg1})
	fake.extractTarballTmpMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSpdxImplementation) ExtractTarballTmpCallCount() int {
	fake.extractTarballTmpMutex.RLock()
	defer fake.extractTarballTmpMutex.RUnlock()
	return len(fake.extractTarballTmpArgsForCall)
}

func (fake *FakeSpdxImplementation) ExtractTarballTmpCalls(stub func(string) (string, error)) {
	fake.extractTarballTmpMutex.Lock()
	defer fake.extractTarballTmpMutex.Unlock()
	fake.ExtractTarballTmpStub = stub
}

func (fake *FakeSpdxImplementation) ExtractTarballTmpArgsForCall(i int) string {
	fake.extractTarballTmpMutex.RLock()
	defer fake.extractTarballTmpMutex.RUnlock()
	argsForCall := fake.extractTarballTmpArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpdxImplementation) ExtractTarballTmpReturns(result1 string, result2 error) {
	fake.extractTarballTmpMutex.Lock()
	defer fake.extractTarballTmpMutex.Unlock()
	fake.ExtractTarballTmpStub = nil
	fake.extractTarballTmpReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSpdxImplementation) ExtractTarballTmpReturnsOnCall(i int, result1 string, result2 error) {
	fake.extractTarballTmpMutex.Lock()
	defer fake.extractTarballTmpMutex.Unlock()
	fake.ExtractTarballTmpStub = nil
	if fake.extractTarballTmpReturnsOnCall == nil {
		fake.extractTarballTmpReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.extractTarballTmpReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSpdxImplementation) PackageFromLayerTarBall(arg1 string, arg2 *spdx.TarballOptions) (*spdx.Package, error) {
	fake.packageFromLayerTarBallMutex.Lock()
	ret, specificReturn := fake.packageFromLayerTarBallReturnsOnCall[len(fake.packageFromLayerTarBallArgsForCall)]
	fake.packageFromLayerTarBallArgsForCall = append(fake.packageFromLayerTarBallArgsForCall, struct {
		arg1 string
		arg2 *spdx.TarballOptions
	}{arg1, arg2})
	stub := fake.PackageFromLayerTarBallStub
	fakeReturns := fake.packageFromLayerTarBallReturns
	fake.recordInvocation("PackageFromLayerTarBall", []interface{}{arg1, arg2})
	fake.packageFromLayerTarBallMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSpdxImplementation) PackageFromLayerTarBallCallCount() int {
	fake.packageFromLayerTarBallMutex.RLock()
	defer fake.packageFromLayerTarBallMutex.RUnlock()
	return len(fake.packageFromLayerTarBallArgsForCall)
}

func (fake *FakeSpdxImplementation) PackageFromLayerTarBallCalls(stub func(string, *spdx.TarballOptions) (*spdx.Package, error)) {
	fake.packageFromLayerTarBallMutex.Lock()
	defer fake.packageFromLayerTarBallMutex.Unlock()
	fake.PackageFromLayerTarBallStub = stub
}

func (fake *FakeSpdxImplementation) PackageFromLayerTarBallArgsForCall(i int) (string, *spdx.TarballOptions) {
	fake.packageFromLayerTarBallMutex.RLock()
	defer fake.packageFromLayerTarBallMutex.RUnlock()
	argsForCall := fake.packageFromLayerTarBallArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpdxImplementation) PackageFromLayerTarBallReturns(result1 *spdx.Package, result2 error) {
	fake.packageFromLayerTarBallMutex.Lock()
	defer fake.packageFromLayerTarBallMutex.Unlock()
	fake.PackageFromLayerTarBallStub = nil
	fake.packageFromLayerTarBallReturns = struct {
		result1 *spdx.Package
		result2 error
	}{result1, result2}
}

func (fake *FakeSpdxImplementation) PackageFromLayerTarBallReturnsOnCall(i int, result1 *spdx.Package, result2 error) {
	fake.packageFromLayerTarBallMutex.Lock()
	defer fake.packageFromLayerTarBallMutex.Unlock()
	fake.PackageFromLayerTarBallStub = nil
	if fake.packageFromLayerTarBallReturnsOnCall == nil {
		fake.packageFromLayerTarBallReturnsOnCall = make(map[int]struct {
			result1 *spdx.Package
			result2 error
		})
	}
	fake.packageFromLayerTarBallReturnsOnCall[i] = struct {
		result1 *spdx.Package
		result2 error
	}{result1, result2}
}

func (fake *FakeSpdxImplementation) PullImagesToArchive(arg1 string, arg2 string) error {
	fake.pullImagesToArchiveMutex.Lock()
	ret, specificReturn := fake.pullImagesToArchiveReturnsOnCall[len(fake.pullImagesToArchiveArgsForCall)]
	fake.pullImagesToArchiveArgsForCall = append(fake.pullImagesToArchiveArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.PullImagesToArchiveStub
	fakeReturns := fake.pullImagesToArchiveReturns
	fake.recordInvocation("PullImagesToArchive", []interface{}{arg1, arg2})
	fake.pullImagesToArchiveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpdxImplementation) PullImagesToArchiveCallCount() int {
	fake.pullImagesToArchiveMutex.RLock()
	defer fake.pullImagesToArchiveMutex.RUnlock()
	return len(fake.pullImagesToArchiveArgsForCall)
}

func (fake *FakeSpdxImplementation) PullImagesToArchiveCalls(stub func(string, string) error) {
	fake.pullImagesToArchiveMutex.Lock()
	defer fake.pullImagesToArchiveMutex.Unlock()
	fake.PullImagesToArchiveStub = stub
}

func (fake *FakeSpdxImplementation) PullImagesToArchiveArgsForCall(i int) (string, string) {
	fake.pullImagesToArchiveMutex.RLock()
	defer fake.pullImagesToArchiveMutex.RUnlock()
	argsForCall := fake.pullImagesToArchiveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpdxImplementation) PullImagesToArchiveReturns(result1 error) {
	fake.pullImagesToArchiveMutex.Lock()
	defer fake.pullImagesToArchiveMutex.Unlock()
	fake.PullImagesToArchiveStub = nil
	fake.pullImagesToArchiveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpdxImplementation) PullImagesToArchiveReturnsOnCall(i int, result1 error) {
	fake.pullImagesToArchiveMutex.Lock()
	defer fake.pullImagesToArchiveMutex.Unlock()
	fake.PullImagesToArchiveStub = nil
	if fake.pullImagesToArchiveReturnsOnCall == nil {
		fake.pullImagesToArchiveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pullImagesToArchiveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpdxImplementation) ReadArchiveManifest(arg1 string) (*spdx.ArchiveManifest, error) {
	fake.readArchiveManifestMutex.Lock()
	ret, specificReturn := fake.readArchiveManifestReturnsOnCall[len(fake.readArchiveManifestArgsForCall)]
	fake.readArchiveManifestArgsForCall = append(fake.readArchiveManifestArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadArchiveManifestStub
	fakeReturns := fake.readArchiveManifestReturns
	fake.recordInvocation("ReadArchiveManifest", []interface{}{arg1})
	fake.readArchiveManifestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSpdxImplementation) ReadArchiveManifestCallCount() int {
	fake.readArchiveManifestMutex.RLock()
	defer fake.readArchiveManifestMutex.RUnlock()
	return len(fake.readArchiveManifestArgsForCall)
}

func (fake *FakeSpdxImplementation) ReadArchiveManifestCalls(stub func(string) (*spdx.ArchiveManifest, error)) {
	fake.readArchiveManifestMutex.Lock()
	defer fake.readArchiveManifestMutex.Unlock()
	fake.ReadArchiveManifestStub = stub
}

func (fake *FakeSpdxImplementation) ReadArchiveManifestArgsForCall(i int) string {
	fake.readArchiveManifestMutex.RLock()
	defer fake.readArchiveManifestMutex.RUnlock()
	argsForCall := fake.readArchiveManifestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpdxImplementation) ReadArchiveManifestReturns(result1 *spdx.ArchiveManifest, result2 error) {
	fake.readArchiveManifestMutex.Lock()
	defer fake.readArchiveManifestMutex.Unlock()
	fake.ReadArchiveManifestStub = nil
	fake.readArchiveManifestReturns = struct {
		result1 *spdx.ArchiveManifest
		result2 error
	}{result1, result2}
}

func (fake *FakeSpdxImplementation) ReadArchiveManifestReturnsOnCall(i int, result1 *spdx.ArchiveManifest, result2 error) {
	fake.readArchiveManifestMutex.Lock()
	defer fake.readArchiveManifestMutex.Unlock()
	fake.ReadArchiveManifestStub = nil
	if fake.readArchiveManifestReturnsOnCall == nil {
		fake.readArchiveManifestReturnsOnCall = make(map[int]struct {
			result1 *spdx.ArchiveManifest
			result2 error
		})
	}
	fake.readArchiveManifestReturnsOnCall[i] = struct {
		result1 *spdx.ArchiveManifest
		result2 error
	}{result1, result2}
}

func (fake *FakeSpdxImplementation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.extractTarballTmpMutex.RLock()
	defer fake.extractTarballTmpMutex.RUnlock()
	fake.packageFromLayerTarBallMutex.RLock()
	defer fake.packageFromLayerTarBallMutex.RUnlock()
	fake.pullImagesToArchiveMutex.RLock()
	defer fake.pullImagesToArchiveMutex.RUnlock()
	fake.readArchiveManifestMutex.RLock()
	defer fake.readArchiveManifestMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSpdxImplementation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
